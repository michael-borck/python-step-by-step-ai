# Creating Your Own Commands: Functions {#sec-functions}

## The Concept First

Imagine if every time you wanted to make coffee, you had to remember and repeat every single step: measure water, grind beans, heat water to 195°F, pour in circles for 30 seconds... It would be exhausting!

Instead, we create a shortcut: "make coffee" - and all those steps happen automatically.

Functions are programming's shortcuts. They package multiple steps into a single, reusable command that you create and name yourself.

## Understanding Through Real Life

### We Use Functions Constantly

Think about everyday "functions":
- **"Do the dishes"** → rinse, soap, scrub, rinse again, dry
- **"Get ready for school"** → shower, dress, eat breakfast, pack bag
- **"Send a text"** → open app, select contact, type message, press send
- **"Make a sandwich"** → get ingredients, assemble, cut, serve

Each phrase represents a collection of steps we've grouped together and named.

### The Power of Naming

When you say "make breakfast," everyone understands the general idea, but the specific steps might vary:
- For you: cereal and milk
- For someone else: eggs and toast
- For another: smoothie and fruit

Functions work the same way - same name, but the details can change based on inputs.

### Functions Save Time and Reduce Errors

Compare:
- Giving turn-by-turn directions every time vs. saying "go to the usual place"
- Explaining how to tie shoes every morning vs. saying "tie your shoes"
- Writing your full address repeatedly vs. saying "my home address"

Functions prevent repetition and ensure consistency.

## Discovering Functions with Your AI Partner

Let's explore how functions transform programming.

### Exploration 1: Finding Repetition

Ask your AI:
```
Show me a program that greets 5 different people without using functions. 
Then show me how it looks with a function.
```

Notice how the function eliminates repetition?

### Exploration 2: The Power of Parameters

Try this prompt:
```
Explain how a coffee-making function might work differently based on inputs 
like "espresso" vs "latte" vs "cappuccino"
```

This shows how functions adapt based on what you give them.

### Exploration 3: Building Blocks

Ask:
```
How do functions help us build larger programs? Use a cooking app as an example.
```

You'll see how complex programs are just collections of simpler functions.

## From Concept to Code

Let's see how Python lets us create our own commands.

### The Simplest Function

Ask your AI:
```
Show me the absolute simplest Python function that just prints "Hello". 
No parameters, no complexity.
```

You'll get something like:
```python
def greet():
    print("Hello!")

# Using our new command
greet()  # Prints: Hello!
```

That's it! `def` creates a function, you name it, and indent what it does.

### Functions with Inputs

Functions become powerful when they accept inputs:
```python
def greet_person(name):
    print(f"Hello, {name}!")

greet_person("Alice")  # Prints: Hello, Alice!
greet_person("Bob")    # Prints: Hello, Bob!
```

The function adapts based on what you give it!

## Mental Model Building

### Model 1: The Recipe Card
```
Recipe: Make Greeting
Ingredients needed: [name]
Steps:
1. Take the name given
2. Add "Hello, " before it
3. Add "!" after it
4. Display the result
```

### Model 2: The Machine
```
     [name] → │ GREET  │ → "Hello, [name]!"
               │MACHINE │
               └────────┘
```

### Model 3: The Shortcut
```
Instead of:
  print("Hello, Alice!")
  print("Hello, Bob!")
  print("Hello, Charlie!")

We create:
  greet("Alice")
  greet("Bob") 
  greet("Charlie")
```

## Prompt Evolution Exercise

Let's practice getting the right function examples from AI.

### Round 1: Too Vague
```
show me functions
```
You'll get complex examples with returns, multiple parameters, and advanced features!

### Round 2: More Specific
```
show me simple Python functions for beginners
```
Better, but might still include concepts you haven't learned.

### Round 3: Learning-Focused
```
I'm learning to create my own commands in Python. Show me a simple function 
that combines greeting and farewell messages.
```
Perfect for understanding!

### Round 4: Building Understanding
```
Using that function, show me how calling it multiple times saves code
```
This demonstrates the value of functions.

## Common AI Complications

When you ask AI about functions, it often gives you:

```python
def calculate_statistics(data_list, operations=['mean', 'median', 'mode'], 
                        precision=2, output_format='dict'):
    """Calculate various statistics on a dataset."""
    import statistics
    import numpy as np
    
    results = {}
    
    for operation in operations:
        if operation == 'mean':
            results[operation] = round(statistics.mean(data_list), precision)
        elif operation == 'median':
            results[operation] = round(statistics.median(data_list), precision)
        elif operation == 'mode':
            try:
                results[operation] = statistics.mode(data_list)
            except statistics.StatisticsError:
                results[operation] = None
    
    if output_format == 'dict':
        return results
    elif output_format == 'list':
        return list(results.values())
    else:
        return tuple(results.values())

# Usage
data = [1, 2, 3, 4, 5, 5, 6]
stats = calculate_statistics(data, ['mean', 'mode'], precision=3)
print(f"Statistics: {stats}")
```

Default parameters! Imports! Error handling! Return values! Documentation! This is a Swiss Army knife when you need a butter knife.

## The Learning Approach

Build understanding step by step:

### Level 1: Simple Actions
```python
# Functions that do one thing
def say_hello():
    print("Hello there!")

def say_goodbye():
    print("See you later!")

# Use them
say_hello()
say_goodbye()
```

### Level 2: Functions with Input
```python
# Functions that adapt based on input
def greet(name):
    print(f"Welcome, {name}!")

def farewell(name):
    print(f"Goodbye, {name}!")

# Use with different inputs
greet("Maria")
farewell("Carlos")
```

### Level 3: Functions that Calculate
```python
# Functions that process and return values
def double(number):
    result = number * 2
    return result

def add_exclamation(text):
    excited = text + "!"
    return excited

# Use the returned values
big = double(5)
print(big)  # 10

shout = add_exclamation("Hello")
print(shout)  # Hello!
```

### Level 4: Functions Using Functions
```python
# Functions can use other functions!
def greet_loudly(name):
    greeting = f"Hello, {name}"
    loud_greeting = add_exclamation(greeting)
    print(loud_greeting)

greet_loudly("Kim")  # Hello, Kim!
```

::: {.callout-note}
## Expression Explorer: Return Values

The `return` statement sends a value back from the function:
- Without `return`: Function does its job but gives nothing back
- With `return`: Function produces a value you can use
- Like the difference between "do the dishes" (action) vs "what's the temperature?" (returns info)

Ask AI: "Show me the difference between functions that print vs functions that return"
:::

## Exercises

::: {.exercise-container}
::: {.exercise-level-badge .level-1-badge}
Exercise 6.1: Concept Recognition
:::

### Identifying Function Opportunities

Look at this repetitive code and identify what could become functions:

```python
print("="*40)
print("WELCOME TO THE GAME")
print("="*40)

name1 = input("Player 1 name: ")
print(f"Welcome, {name1}!")

name2 = input("Player 2 name: ")
print(f"Welcome, {name2}!")

print("="*40)
print("GAME OVER")
print("="*40)
```

<details>
<summary>Check Your Analysis</summary>
Function opportunities:
- Banner display (the ='s with text)
- Player welcome (get name and greet)
- Any repeated pattern is a function candidate!
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-2-badge}
Exercise 6.2: Prompt Engineering
:::

### Getting Function Examples

Start with: "temperature converter"

Evolve this prompt to get AI to show you:
1. A function that converts Celsius to Fahrenheit
2. Accepts temperature as input
3. Returns the converted value
4. Keep it simple (no error handling)

Document your prompt evolution.

<details>
<summary>Effective Final Prompt</summary>
"Show me a simple Python function that:
1. Takes a Celsius temperature as input
2. Converts it to Fahrenheit  
3. Returns the result
No error handling or extra features, just the basic conversion function"
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-3-badge}
Exercise 6.3: Pattern Matching
:::

### Finding Hidden Functions

Ask AI for a "professional menu system". In the complex code:
1. Identify all the functions
2. Determine what each function does
3. Rewrite using 3-4 simple functions

<details>
<summary>Core Functions to Extract</summary>
Essential functions might be:
- `display_menu()` - Shows options
- `get_choice()` - Gets user selection
- `process_choice(choice)` - Handles the selection
- `say_goodbye()` - Exit message

Everything else is probably AI overengineering!
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-4-badge}
Exercise 6.4: Build a Model
:::

### Visualizing Function Flow

Create three different models showing how functions work:
1. A diagram showing data flow through a function
2. An analogy using a vending machine
3. A before/after comparison of code with and without functions

Share your models to explain functions to someone.
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-5-badge}
Exercise 6.5: Architect First
:::

### Design Function-Based Programs

Design these programs using functions:

1. **Greeting System**
   - Functions needed: formal_greeting(), casual_greeting(), goodbye()
   - Each takes a name and creates appropriate message

2. **Calculator**
   - Functions needed: add(), subtract(), multiply(), divide()
   - Each takes two numbers and returns result

3. **Game Utilities**
   - Functions needed: roll_dice(), flip_coin(), draw_card()
   - Each returns a random result

Write your design as:
- Function name and purpose
- What inputs it needs
- What it returns or does
- How functions work together

Then ask AI: "Implement these exact functions: [your design]"

<details>
<summary>Design Example</summary>
**Greeting System Design**:
- `formal_greeting(name)` - Takes name, returns "Good day, Mr./Ms. [name]"
- `casual_greeting(name)` - Takes name, returns "Hey [name]!"
- `goodbye(name)` - Takes name, prints farewell message
- Main program uses all three based on user choice
</details>
:::

## AI Partnership Patterns

### Pattern 1: Refactoring to Functions
Show AI repetitive code and ask:
- "What parts of this code repeat?"
- "How would functions reduce this repetition?"
- "Show me the simplest function version"

### Pattern 2: Function Evolution
Build complexity gradually:
1. "Show a function that prints a greeting"
2. "Now make it accept a name"
3. "Now make it return the greeting instead"
4. "Now add a style parameter (formal/casual)"

### Pattern 3: Real-World Connections
Connect functions to familiar concepts:
- "Explain functions like TV remote buttons"
- "How are functions like phone contacts?"
- "Compare functions to keyboard shortcuts"

## Common Misconceptions

### "Functions must be complex"
**Reality**: The best functions do one thing well:
```python
def add_two(number):
    return number + 2
# Perfectly valid and useful!
```

### "Functions can't use other functions"
**Reality**: Functions can call other functions - this is how we build complex programs from simple pieces:
```python
def get_greeting(name):
    return f"Hello, {name}"

def greet_loudly(name):
    greeting = get_greeting(name)
    print(greeting.upper() + "!!!")
```

### "Print and return are the same"
**Reality**: 
- `print()` displays to screen (side effect)
- `return` sends value back to use elsewhere (result)
```python
def bad_double(x):
    print(x * 2)  # Just shows it

def good_double(x):
    return x * 2  # Gives it back to use

result = good_double(5)  # Can use the 10
```

## Real-World Connection

Every app is built from functions:

**Calculator App**:
```python
def add(a, b):
    return a + b

def subtract(a, b):
    return a - b

def calculate_tax(amount):
    return amount * 0.08
```

**Game Functions**:
```python
def move_player(direction):
    # Update position

def check_collision():
    # Detect crashes

def update_score(points):
    # Add to score
```

**Social Media**:
```python
def post_update(message):
    # Share message

def like_post(post_id):
    # Add like

def add_friend(username):
    # Connect users
```

## Chapter Summary

You've learned:
- Functions package multiple steps into reusable commands
- Parameters let functions adapt to different inputs
- Return values let functions produce results
- Functions calling functions creates powerful programs
- Good function names make code self-documenting

## Reflection Checklist

Before moving to Chapter 7, ensure you:

- [ ] Understand functions as named groups of commands
- [ ] Can create simple functions with and without parameters
- [ ] Know the difference between print and return
- [ ] Can identify repetitive code that needs functions
- [ ] See how functions make programs modular and reusable

## Your Learning Journal

For this chapter, record:

1. **Function Opportunities**: Find 5 repetitive tasks in your daily life that could be "functions"
2. **Code Comparison**: Write greeting code with and without functions - which is clearer?
3. **Mental Models**: Draw your favorite visualization of how functions work
4. **Design Practice**: List functions needed for a simple recipe app

::: {.callout-tip}
## The Power of Good Names
Well-named functions make code read like English:
```python
def make_sandwich(filling):
    bread = get_bread()
    spread = add_condiments()
    result = combine(bread, filling, spread)
    return result

lunch = make_sandwich("turkey")
```
Anyone can understand what this does!
:::

## Next Steps

In Chapter 7, we'll explore how to organize complex information using lists and dictionaries. You'll see how functions and data structures work together to create powerful programs that can handle real-world complexity.

Remember: Functions aren't about memorizing syntax. They're about recognizing patterns, reducing repetition, and building programs from well-named, reusable pieces!