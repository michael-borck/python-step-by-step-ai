# Asking Questions: Getting Input {#sec-input}

## The Concept First

Programs are conversations. They need to ask questions and listen to answers. Without this ability, a program would be like a friend who only talks but never listens - not very useful!

Getting input is how programs become interactive, personal, and responsive to what users need.

## Understanding Through Real Life

### Every Interaction Requires Input

Think about daily conversations that require input:

**At a coffee shop:**
- "What's your name?" → You provide input
- "What size?" → You provide input
- "Any milk or sugar?" → You provide input

**Using an ATM:**
- "Enter your PIN" → You provide input
- "How much to withdraw?" → You provide input
- "Do you want a receipt?" → You provide input

**Playing a game:**
- "Enter player name" → You provide input
- "Choose difficulty" → You provide input
- "Press any key to continue" → You provide input

Without the ability to ask and receive answers, these interactions couldn't happen.

### The Question-Answer Pattern

Every input follows the same pattern:
1. Program asks a question (prompt)
2. User provides an answer (input)
3. Program remembers the answer (variable)
4. Program uses the answer (process)

## Discovering Input with Your AI Partner

Let's explore how programs ask questions and get answers.

### Exploration 1: Types of Questions

Ask your AI:
```
What are 5 different types of questions a program might ask users? Give examples without code.
```

You'll see categories like:
- Identity questions (What's your name?)
- Choice questions (Yes or no?)
- Quantity questions (How many?)
- Preference questions (Which color?)

### Exploration 2: Real App Inputs

Try this prompt:
```
List all the inputs Instagram asks for when you create a new post
```

Notice how each input serves a specific purpose in the app's functionality.

### Exploration 3: Input in Action

Ask:
```
Explain the flow of what happens when a user types their name into a program, from keyboard press to program memory
```

This helps you understand the complete input process.

## From Concept to Code

Let's see how Python implements this conversational pattern.

### The Simplest Expression

Ask your AI:
```
Show me the absolute simplest Python example of asking the user a question and using their answer. Nothing fancy.
```

You'll get something like:
```python
name = input("What's your name? ")
print("Hello, " + name)
```

That's it! `input()` displays a prompt and waits for an answer.

### Understanding the Flow

Let's trace what happens:
```python
age = input("How old are you? ")
```

1. Python displays: "How old are you? "
2. Program pauses and waits
3. User types: 25
4. User presses Enter
5. `age` now contains "25" (as text)

## Mental Model Building

### Model 1: The Conversation
```
Program: "What's your name?"    [PROMPT]
           ↓
User: *types* "Alice"           [INPUT]
           ↓
Program: (stores in variable)   [MEMORY]
           ↓
Program: "Hello, Alice!"        [OUTPUT]
```

### Model 2: The Form Field
Think of `input()` like a form field:
```
┌─────────────────────────┐
│ What's your name? _____ │ <- User fills in the blank
└─────────────────────────┘
```

### Model 3: The Pause Button
```
Program running...
→ Hit input() - PAUSE! Wait for user...
→ User types...
→ User presses Enter - RESUME!
Program continues with the answer...
```

## Prompt Evolution Exercise

Let's practice getting the right examples from AI.

### Round 1: Too Vague
```
show me input
```
AI might show file input, network input, or complex forms!

### Round 2: More Specific
```
show me Python user input
```
Better, but might include GUI elements or web forms.

### Round 3: Learning-Focused
```
I'm learning to get keyboard input from users in Python. Show me the simplest example of asking for their name.
```
Perfect for learning!

### Round 4: Building Understanding
```
Using that example, show me step-by-step what happens when the user types "Sam" and presses Enter
```
This reinforces the mental model.

## Common AI Complications

When you ask AI about input, it often gives you:

```python
def get_validated_input(prompt, validator=None, error_msg="Invalid input"):
    """Get input with validation and error handling"""
    while True:
        try:
            user_input = input(prompt).strip()
            
            if not user_input:
                print("Input cannot be empty. Please try again.")
                continue
                
            if validator and not validator(user_input):
                print(error_msg)
                continue
                
            return user_input
            
        except KeyboardInterrupt:
            print("\nOperation cancelled.")
            return None
        except EOFError:
            print("\nNo input provided.")
            return None

# Usage with validation
def is_valid_age(age_str):
    try:
        age = int(age_str)
        return 0 <= age <= 150
    except ValueError:
        return False

name = get_validated_input("Enter your name: ")
age = get_validated_input(
    "Enter your age: ", 
    validator=is_valid_age,
    error_msg="Please enter a valid age (0-150)"
)
```

Validation! Error handling! Functions! Type checking! This is production code, not learning code.

## The Learning Approach

Build understanding progressively:

### Level 1: Basic Question and Answer
```python
# Ask one question
favorite_food = input("What's your favorite food? ")
print("I love " + favorite_food + " too!")
```

### Level 2: Multiple Questions
```python
# Building a story with inputs
hero_name = input("Enter hero name: ")
villain_name = input("Enter villain name: ")
location = input("Where does the story take place? ")

print(hero_name + " must save " + location + " from " + villain_name + "!")
```

### Level 3: Input + Variables + Process
```python
# Complete I→P→O with memory
price = input("Enter item price: ")      # INPUT
tax = float(price) * 0.08               # PROCESS (8% tax)
total = float(price) + tax              # PROCESS
print("Total with tax: $" + str(total)) # OUTPUT
```

::: {.callout-note}
## Expression Explorer: Type Conversion in Calculations

Notice how we handle input in calculations:
- `float(price)` converts text to decimal number
- `* 0.08` multiplies for percentage (8% = 0.08)
- `str(total)` converts number back to text for display

Ask AI: "Why do I need float() for calculations but str() for printing?"
:::

### Level 4: Building Interactive Programs
```python
# A simple calculator
print("Simple Calculator")
first = input("First number: ")
second = input("Second number: ")
sum_result = int(first) + int(second)
print(first + " + " + second + " = " + str(sum_result))
```

## Exercises

::: {.exercise-container}
::: {.exercise-level-badge .level-1-badge}
Exercise 3.1: Concept Recognition
:::

### Identifying Input Patterns

For each scenario, identify:
1. What question is asked
2. What variable stores the answer
3. How the answer is used

**Program A:**
```python
city = input("Where do you live? ")
print("I've heard " + city + " is beautiful!")
```

**Program B:**
```python
pet_name = input("What's your pet's name? ")
pet_type = input("What kind of pet is it? ")
print(pet_name + " sounds like a wonderful " + pet_type)
```

<details>
<summary>Check Your Analysis</summary>

**Program A:**
- Question: "Where do you live?"
- Variable: `city`
- Usage: Incorporated into a compliment about the city

**Program B:**
- Questions: Pet's name and type
- Variables: `pet_name`, `pet_type`
- Usage: Combined to create a personalized message
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-2-badge}
Exercise 3.2: Prompt Engineering
:::

### Getting Interactive Examples

Start with: "user input program"

Evolve this prompt to get AI to show you:
1. A program that asks for someone's hobby
2. Stores it in a well-named variable
3. Uses it in two different print statements
4. Keeps it simple (no functions or validation)

Document each prompt iteration.

<details>
<summary>Effective Final Prompt</summary>
"Show me a simple Python program that:
1. Asks the user for their favorite hobby
2. Stores it in a variable
3. Prints two different messages using that hobby
Use only input() and print(), nothing complex"
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-3-badge}
Exercise 3.3: Pattern Matching
:::

### Finding Core Input Patterns

Ask AI for a "professional user registration system". In the complex code:
1. Find all the input() calls
2. Identify the essential questions
3. Rewrite as a simple 4-5 line program

<details>
<summary>What to Extract</summary>
Essential inputs might be:
- Username
- Email
- Password

Strip away:
- Validation
- Error handling
- Database code
- Encryption
- Email verification

Keep just the core question-asking pattern!
</details>
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-4-badge}
Exercise 3.4: Build a Model
:::

### Visualizing Input Flow

Create three different models showing how input works:
1. A comic strip showing the conversation
2. A flowchart of the input process
3. An analogy using something non-computer related

Test your models by explaining input() to someone who's never programmed.
:::

::: {.exercise-container}
::: {.exercise-level-badge .level-5-badge}
Exercise 3.5: Architect First
:::

### Design Interactive Programs

Design these programs before coding:

1. **Personal Greeting Bot**
   - Questions needed: name, mood, favorite color
   - Output: Personalized colorful greeting

2. **Simple Story Generator**
   - Questions needed: character name, place, object
   - Output: A two-sentence story using all inputs

3. **Basic Pizza Order**
   - Questions needed: size, topping, delivery address
   - Output: Order confirmation

Write your design as:
- List of questions to ask
- Variable names for each answer
- How you'll use the variables

Then ask AI: "Implement this exact design: [your design]"

<details>
<summary>Design Example</summary>
**Personal Greeting Bot Design:**
- Ask "What's your name?" → store in `user_name`
- Ask "How are you feeling?" → store in `mood`
- Ask "Favorite color?" → store in `color`
- Output: "Hi [name]! Hope your [mood] day gets even better! [color] is awesome!"
</details>
:::

## AI Partnership Patterns

### Pattern 1: Trace the Journey
Ask AI to trace data flow:
- "Show what happens to user input from keyboard to variable"
- "Trace the value '42' through this input() example"
- "Draw a diagram of the input() process"

### Pattern 2: Real-World Connections
Connect to familiar experiences:
- "Explain input() like a restaurant taking your order"
- "Compare input() to filling out a form"
- "How is input() like having a conversation?"

### Pattern 3: Common Mistakes
Learn from errors:
- "What happens if I forget to store input() in a variable?"
- "Why does input() always return text, not numbers?"
- "Show me common beginner mistakes with input()"

## Common Misconceptions

### "input() returns numbers when I type numbers"
**Reality**: `input()` ALWAYS returns text (strings)
```python
age = input("Your age: ")  # User types: 25
# age contains "25" (text), not 25 (number)
# To get a number: age = int(input("Your age: "))
```

### "I need to print the question separately"
**Reality**: `input()` displays the prompt for you
```python
# Unnecessary:
print("What's your name?")
name = input()

# Better:
name = input("What's your name? ")
```

### "Complex programs need complex input handling"
**Reality**: Even big programs often use simple input patterns. Complexity can be added later if needed.

## Real-World Connection

Every app gets input somehow:

**Text Messages:**
- Input: Typing your message
- Input: Choosing emoji
- Input: Selecting recipient

**Online Shopping:**
- Input: Search terms
- Input: Quantity
- Input: Shipping address
- Input: Payment info

**Video Games:**
- Input: Character name
- Input: Difficulty level
- Input: Control settings

The concept is universal - only the implementation differs!

## Chapter Summary

You've learned:
- Programs need input to be interactive
- `input()` creates a conversation with users
- Input always returns text that needs storage
- Questions should be clear and purposeful
- Simple input patterns power complex programs

## Reflection Checklist

Before moving to Chapter 4, ensure you:

- [ ] Understand input as program-user conversation
- [ ] Can write clear prompts for input()
- [ ] Know input() always returns text
- [ ] Can combine input with variables and output
- [ ] See how input completes the I→P→O pattern

## Your Learning Journal

For this chapter, record:

1. **Real-World Inputs**: List 10 times you provided input to technology today
2. **Prompt Practice**: Write 5 different ways to ask for someone's age
3. **Mental Model**: Draw your favorite visualization of how input() works
4. **Program Ideas**: List 3 programs you could build with just input(), variables, and print()

::: {.callout-tip}
## The Art of Good Prompts
A good input prompt is like a good question in conversation:
- Clear about what you want
- Friendly in tone
- Shows expected format when helpful
- Ends with a space for readability

Compare:
- Bad: `input("name")`
- Good: `input("What's your name? ")`
- Better: `input("Please enter your name: ")`
:::

## Next Steps

In Chapter 4, we'll discover how programs make decisions using if statements. You'll see how input becomes powerful when programs can respond differently based on what users tell them. Get ready to make your programs smart!

Remember: Getting input isn't about the syntax of `input()`. It's about creating conversations between programs and people. Every interactive program in the world is built on this simple concept.